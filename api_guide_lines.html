<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>API Reference Manual: API Developer Guidelines</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="odpdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ODP-Logo-HQ.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">API Reference Manual
   &#160;<span id="projectnumber">1.48.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('api_guide_lines.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">API Developer Guidelines </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#introduction">Introduction</a></li>
<li class="level1"><a href="#functional">Functional Definition</a><ul><li class="level2"><a href="#naming">Naming Conventions</a></li>
<li class="level2"><a href="#data_types">Data Types and Use of typedef</a></li>
<li class="level2"><a href="#parameters">Parameter Structure and Validation</a></li>
<li class="level2"><a href="#function_name">Function Names</a></li>
<li class="level2"><a href="#getters">Getting information</a><ul><li class="level3"><a href="#is_has">Is / Has</a></li>
<li class="level3"><a href="#get">Get</a></li>
</ul>
</li>
<li class="level2"><a href="#converter">Converter Functions</a></li>
<li class="level2"><a href="#function_calls">Function Calls</a></li>
<li class="level2"><a href="#errno">Use of errno</a></li>
<li class="level2"><a href="#boolean">Boolean</a></li>
<li class="level2"><a href="#success">Success and Failure</a></li>
<li class="level2"><a href="#odp_internal">Internal APIs</a></li>
<li class="level2"><a href="#variables">Declaring variables</a></li>
</ul>
</li>
<li class="level1"><a href="#implementation">Implementation Considerations</a><ul><li class="level2"><a href="#application_view">Application View vs. Implementation View</a></li>
<li class="level2"><a href="#essential_functions">Essential functions vs. Extensions</a></li>
<li class="level2"><a href="#odp_deprecate">ODP DEPRECATE</a></li>
</ul>
</li>
<li class="level1"><a href="#defaults">Default behaviours</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="introduction"></a>
Introduction</h1>
<p>ODP APIs are implemented as callable C functions that often return a typed value. This document describes the approach to handling return values and error indications expected of conforming ODP implementations. As such it should be regarded as providing guidelines for how to create new ODP APIs.</p>
<h1><a class="anchor" id="functional"></a>
Functional Definition</h1>
<p>This section defines the use of data types, calling conventions, and return codes used by ODP APIs. All ODP APIs MUST follow these conventions as part of their design.</p>
<h2><a class="anchor" id="naming"></a>
Naming Conventions</h2>
<p>All ODP APIs begin with the prefix odp_ and those that describe an action to be performed on an object follow the naming convention of object followed by action. The advantage of this approach is that an alphabetical list of APIs for an object all sort together since they all have names of the form odp_object_action().</p>
<p>So for example the API call to allocate a buffer is named <a class="el" href="group__odp__buffer.html#ga2d7e4d7385b794f5016c000a94361dbd" title="Buffer alloc.">odp_buffer_alloc()</a> rather than odp_alloc_buffer().</p>
<h2><a class="anchor" id="data_types"></a>
Data Types and Use of typedef</h2>
<p>ODP is designed to allow broad variability in how APIs are implemented on various platforms. To support this, most APIs operate on abstract data types that are defined via typedef on a per-implementation basis. These abstract types follow the naming convention of odp_object_t.</p>
<p>Typedefs that encapsulate C structs follow the convention:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>odp_&lt;descriptive_name&gt;_s {</div>
<div class="line">...</div>
<div class="line">} odp_&lt;descriptive_name&gt;_t;</div>
</div><!-- fragment --><p>The use of typedef allows implementations to choose underlying data representations that map efficiently to platform capabilities while providing accessor functions to provide structured access to implementation information in a portable manner. Similarly, the use of enum is RECOMMENDED to provide value abstraction for API parameters while enabling the implementation to choose code points that map well to platform native values.</p>
<p>Several native C types are used conventionally within ODP and SHOULD be employed in API design:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">type   </th><th class="markdownTableHeadLeft">Correct use    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">void   </td><td class="markdownTableBodyLeft">SHOULD be used for APIs that do not return a value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">void*   </td><td class="markdownTableBodyLeft">SHOULD be used for APIs that return a pointer intended to be used by the caller. For example, a routine that returns the address of an application context area SHOULD use a void * return type    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">odp_bool_t   </td><td class="markdownTableBodyLeft">SHOULD be used for APIs that return a <a class="el" href="api_guide_lines.html#boolean">Boolean</a> value.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">int   </td><td class="markdownTableBodyLeft">SHOULD be used for success and failure indications, with 0 indicating a success. Errno may be set   </td></tr>
</table>
<h2><a class="anchor" id="parameters"></a>
Parameter Structure and Validation</h2>
<p>ODP is a framework for use in the data plane. Data plane applications typically have extreme performance requirements mandating very strict attention to path length considerations in the design of all ODP APIs, with the exception of those designed to be used infrequently such as only during initialization or termination processing.</p>
<p>Minimizing pathlength in API design involves several considerations:</p><ul>
<li>The number of parameters passed to a call. In general, ODP APIs designed for frequent use SHOULD have few parameters. Limiting parameter count to one or two well-chosen parameters SHOULD be the goal for APIs designed for frequent use. If a call requires more complex parameter data then it is RECOMMENDED that instead of multiple parameters, a single pointer to a struct that can be statically templated and modified by the caller be used.</li>
<li>The use of macros and inlining. ODP APIs MAY be implemented as preprocessor macros and/or inline functions. This is especially true for accessor functions that are designed to provide getters/setters for object meta data.</li>
<li>Limiting parameter validation and error-checking processing. While useful for development and debugging, providing "bullet-proof" APIs that perform extensive parameter validation and error checking is often inappropriate. While validations that can be performed statically at compile time or at little to no runtime cost SHOULD be considered, APIs MAY choose to leave behavior as undefined when presented with invalid parameters in the interest of runtime efficiency.</li>
</ul>
<p>One of the reasons for using abstract types is to avoid having implementation knowledge "bleed through" the API, leading to possible parameter errors. When one API returns an opaque token to an application it is reasonable to expect that the application can pass that token to subsequent APIs without needing expensive runtime validation.</p>
<p>ODP provides the helper APIs <a class="el" href="group__odp__initialization.html#ga1c51393d64c840c04df3536b6fe40b95" title="Compile time assertion macro.">ODP_STATIC_ASSERT(cond,msg)</a> and ODP_ASSERT(cond,msg) that SHOULD be used in implementations for performing appropriate validation. The former is a compile-time assertion and hence adds no additional path length. The latter is controlled by the ODP_NO_DEBUG compile-time switch and so is suitable for use in development/debug builds that can be compiled out for production use. Other mechanisms available to the implementer are:</p><ul>
<li>ODP_ABORT() is provided for situations where further execution of the code must not occur and a level of tracing information should be left in the log.</li>
<li><a class="el" href="spec_2deprecated_8h.html#a786468a661c5893b85056570943bfb2b" title="Macro to deprecate API definitions.">ODP_DEPRECATE()</a> is used to signify that a call is planned for obsolescence.</li>
<li>ODP_LOG() is used to direct implementation messages to the application.</li>
</ul>
<h2><a class="anchor" id="function_name"></a>
Function Names</h2>
<p>Functions must attempt to be so clear in their intent that referencing the documentation is not necessary, the guidelines below should be followed unless a strong case is made for an exception.</p>
<h2><a class="anchor" id="getters"></a>
Getting information</h2>
<h3><a class="anchor" id="is_has"></a>
Is / Has</h3>
<p>An API with "is" or "has" are both considered <a class="el" href="api_guide_lines.html#boolean">Boolean</a> questions. They can only return true or false and it reflects the current state of something.</p>
<p>An example might be a packet interface, you might want to know if it is in promiscuous mode. </p><div class="fragment"><div class="line"><a class="code" href="group__odp__std.html#ga0b2a7ca83ccc7af0346db309d8c06d6f">odp_bool_t</a> state = odp_pktio_is_promiscuous(pktio handle) </div>
<div class="ttc" id="agroup__odp__std_html_ga0b2a7ca83ccc7af0346db309d8c06d6f"><div class="ttname"><a href="group__odp__std.html#ga0b2a7ca83ccc7af0346db309d8c06d6f">odp_bool_t</a></div><div class="ttdeci">bool odp_bool_t</div><div class="ttdoc">Boolean type.</div><div class="ttdef"><b>Definition:</b> <a href="api_2abi-default_2std__types_8h_source.html#l00025">api/abi-default/std_types.h:25</a></div></div>
</div><!-- fragment --><p>In addition you might want to know if it has the ability to be in promiscuous mode. </p><div class="fragment"><div class="line"><a class="code" href="group__odp__std.html#ga0b2a7ca83ccc7af0346db309d8c06d6f">odp_bool_t</a> state = odp_pktio_has_promiscuous(pktio handle) </div>
</div><!-- fragment --><p>Another case might be if a packet has a vlan flag set </p><div class="fragment"><div class="line"><a class="code" href="group__odp__std.html#ga0b2a7ca83ccc7af0346db309d8c06d6f">odp_bool_t</a> state = <a class="code" href="group__odp__packet.html#ga9e3e865a777eb4a8e51632cc206e73ce">odp_packet_has_vlan</a>(packet handle) </div>
<div class="ttc" id="agroup__odp__packet_html_ga9e3e865a777eb4a8e51632cc206e73ce"><div class="ttname"><a href="group__odp__packet.html#ga9e3e865a777eb4a8e51632cc206e73ce">odp_packet_has_vlan</a></div><div class="ttdeci">int odp_packet_has_vlan(odp_packet_t pkt)</div><div class="ttdoc">Check for VLAN.</div></div>
</div><!-- fragment --><h3><a class="anchor" id="get"></a>
Get</h3>
<p>Where possible returned information should be an enum if it reflects a finite list of information. In general, get APIs drop the actual tag "get" in the function name.</p>
<h2><a class="anchor" id="converter"></a>
Converter Functions</h2>
<p>To maintain efficiency in fastpath code, converter functions should expect correct inputs with undefined results otherwise.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> odp_foo_t _odp_foo_from_bar(odp_bar_t bar)</div>
<div class="line">{</div>
<div class="line">       <span class="keywordflow">return</span> (odp_foo_t)bar;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="function_calls"></a>
Function Calls</h2>
<p>ODP APIs typically have prototypes of the form:</p>
<div class="fragment"><div class="line">odp_return_type_t odp_api(p1_type p1, p2_type p2, ...);</div>
</div><!-- fragment --><p> Where:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">type   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">odp_return_type_t   </td><td class="markdownTableBodyLeft">Is the return value produced by the API call. As noted above, the native types void, void *, and int are also used. Other APIs return abstract types defined via typedef    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">p1_type   </td><td class="markdownTableBodyLeft">Is the data type of the first parameter    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">p2_type   </td><td class="markdownTableBodyLeft">Is the data type of the second parameter, etc.   </td></tr>
</table>
<p>For ODP APIs that return void, results are undefined if the input parameters are invalid. For those that return void *, the value ODP_NULL or ODP_INVALID MAY be used to indicate call failure. For non-boolean APIs returning int, a return value of 0 indicates success while non-zero indicates failure see <a class="el" href="api_guide_lines.html#success">Success and Failure</a>.</p>
<h2><a class="anchor" id="errno"></a>
Use of errno</h2>
<p>ODP APIs SHOULD make use of the thread-local variable errno, defined in the standard library include file errno.h, to indicate a reason for an API call failure when appropriate. This convention allows callers to easily determine success/failure of a call with a single test and then decode the failure as desired from the extended reason provided by errno. So, for example, an attempt to allocate a buffer from a buffer pool might return ODP_BUFFER_INVALID if the call was unsuccessful and errno could then be set to an appropriate reason (no storage available (ENOMEM, ENOBUFS), pool not recognized (EINVAL), etc.).</p>
<p>In general APIs are free to define their own errno usage conventions and values or reuse standard errno values when appropriate. When "standard" codes exist, implementations SHOULD make use of them so that standard utility functions like perror() can decode them intelligently. There are, however, a small set of standard codes that are commonly used. One errno value that MUST be present for all APIs is ODP_FUNCTION_NOT_AVAILABLE. This special reason code is used to indicate that the underlying implementation does not support the requested API, and SHOULD be equated to ENOSYS. This may be because the requested API is specifically designated as OPTIONAL or that the caller is using a pre-release version of an API that does not have all functionality implemented yet.</p>
<p>Another standard errno is ODP_IMPLEMENTATION_LIMIT. This code SHOULD be used if a API call is made that exceeds a permitted limit of the underlying implementation, and SHOULD be equated to ERANGE. For example, many APIs MAY mandate certain minimum functionality but provide latitude on maximums. An example of this might be the number of queues that an application can create. An attempt to allocate more queues than the underlying implementation supports would result in this failure code being returned via errno.</p>
<h2><a class="anchor" id="boolean"></a>
Boolean</h2>
<p>For ODP all booleans are integers. To aid application readability they are defined as the type odp_bool_t. The values !0 = true, 0 = false are used for this purpose.</p>
<h2><a class="anchor" id="success"></a>
Success and Failure</h2>
<p>Pass indications are integers (int) and SHOULD also be used for APIs that return a simple success/failure indication to the caller. In this case the return value 0 indicates success while non-zero (typically -1) indicates failure and errno is set to a reason code that indicates the nature of the failure.</p>
<h2><a class="anchor" id="odp_internal"></a>
Internal APIs</h2>
<p>When an interface is defined in a header file and is intended to to be reused internally it will follow these rules:-</p><ul>
<li>Be prefixed with an underscore "_".</li>
<li>All the required definitions for the API are to use an underscore, this includes MACROS, typedefs, enums and function names.</li>
</ul>
<h2><a class="anchor" id="variables"></a>
Declaring variables</h2>
<ul>
<li>Variables shall be declared at the beginning of scope, for example :- <div class="fragment"><div class="line"><span class="keywordtype">int</span> start_of_global_scope;</div>
<div class="line"> </div>
<div class="line">main () {</div>
<div class="line">  <span class="keywordtype">int</span> start_of_function_scope;</div>
<div class="line">  ...</div>
<div class="line">  <span class="keywordflow">if</span> (foo == bar) {</div>
<div class="line"><span class="keywordtype">int</span> start_of_block_scope;</div>
<div class="line">...</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --></li>
</ul>
<h1><a class="anchor" id="implementation"></a>
Implementation Considerations</h1>
<p>To support application portability and preserve implementation flexibility, ODP APIs MUST be designed with several guiding principles in mind.</p>
<h2><a class="anchor" id="application_view"></a>
Application View vs. Implementation View</h2>
<p>ODP APIs MUST present an application view of a problem in their externals. That is, the API should allow the application to specify what it wants to do while the underlying implementation of that API controls how the requested function is realized. As a result, ODP APIs SHOULD NOT be designed with a specific implementation in mind. This is the reason, for example, that packet I/O in ODP follows a queued model. It is an implementation responsibility to determine how packets are physically read and written, and whatever internal structures are needed to perform this most efficiently are an implementation rather than an application concern. In some platforms this may involve the use of receive rings and buffer bursting, while in others this may be a simple memory-mapped register operation to interface with a hardware packet scheduler/distributor. The ODP application does not care how packets arrive for processing only that a packet is available for it to work on.</p>
<p>Similarly, ODP applications reference packets data fields in terms of the information that is needed, rather than focusing on how that information is obtained. The assumption is that the underlying implementation has pre-parsed the packet to extract the most relevant data as packet meta data that is immediately available to the application without requiring the application to do this work itself. Over time, as network speeds increase, more and higher level networking functions are expected to migrate directly into hardware and ODP APIs MUST be mindful of this evolution in their design.</p>
<h2><a class="anchor" id="essential_functions"></a>
Essential functions vs. Extensions</h2>
<p>At the same time, APIs SHOULD reflect essential needs of data plane application programming and SHOULD NOT strive to offer comprehensive solutions to every possible contingency. How to draw this line is a judgement call based on experience but API designers MUST take implementation practicalities into consideration when designing APIs to ensure that APIs and features can be implemented efficiently on a wide variety of underlying platforms. This is one of the reasons why some features MAY be defined as OPTIONAL. While allowed, the proliferation of OPTIONAL features SHOULD be avoided to enable broad application portability across many implementations. At the same time, a "least common denominator" approach MUST NOT be taken as that defeats the purpose of providing higher-level abstractions in APIs.</p>
<h2><a class="anchor" id="odp_deprecate"></a>
ODP DEPRECATE</h2>
<p>A deprecated API will remain marked as such in the public API using <a class="el" href="spec_2deprecated_8h.html#a786468a661c5893b85056570943bfb2b" title="Macro to deprecate API definitions.">ODP_DEPRECATE()</a> for two release cycles for the <a class="el" href="group__odp__version.html#ga7218febf8005dff559283122371e5a08" title="ODP API major version.">ODP_VERSION_API_MAJOR</a> number. For example an API marked as deprecated in 1.1.0 will still be present in 1.2.0 and removed in 1.3.0. A deprecated API will contain the doxygen tag @deprecated with a description of the reason for the change.</p>
<h1><a class="anchor" id="defaults"></a>
Default behaviours</h1>
<p>When an API has a default behaviour it must be possible for the application to explicitly call for that behaviour; this guards against the default changing and breaking the application. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
