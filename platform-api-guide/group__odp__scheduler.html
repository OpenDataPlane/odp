<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>API Reference Manual for linux-generic: ODP SCHEDULER</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="odpdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ODP-Logo-HQ.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">API Reference Manual for linux-generic
   &#160;<span id="projectnumber">1.48.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__odp__scheduler.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ODP SCHEDULER</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">API Description</h2>
<p>Event scheduler for work load balancing and prioritization. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structodp__schedule__param__t.html">odp_schedule_param_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduler parameters.  <a href="structodp__schedule__param__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structodp__schedule__capability__t.html">odp_schedule_capability_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduler capabilities.  <a href="structodp__schedule__capability__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structodp__cache__stash__region__t.html">odp_cache_stash_region_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Region specific cache stashing configuration.  <a href="structodp__cache__stash__region__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structodp__cache__stash__config__t.html">odp_cache_stash_config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache stashing configuration.  <a href="structodp__cache__stash__config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structodp__cache__stash__prio__config__t.html">odp_cache_stash_prio_config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Priority specific cache stashing configuration.  <a href="structodp__cache__stash__prio__config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structodp__schedule__group__param__t.html">odp_schedule_group_param_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule group parameters.  <a href="structodp__schedule__group__param__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structodp__schedule__config__t.html">odp_schedule_config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule configuration.  <a href="structodp__schedule__config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structodp__schedule__group__info__t.html">odp_schedule_group_info_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule group information.  <a href="structodp__schedule__group__info__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga082e6855e67281d9f868152c7daa844a"><td class="memItemLeft" align="right" valign="top"><a id="ga082e6855e67281d9f868152c7daa844a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga082e6855e67281d9f868152c7daa844a">ODP_SCHED_WAIT</a>&#160;&#160;&#160;UINT64_MAX</td></tr>
<tr class="memdesc:ga082e6855e67281d9f868152c7daa844a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait infinitely. <br /></td></tr>
<tr class="separator:ga082e6855e67281d9f868152c7daa844a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9116776b8262a74af7dac7ef46fc7ace"><td class="memItemLeft" align="right" valign="top"><a id="ga9116776b8262a74af7dac7ef46fc7ace"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga9116776b8262a74af7dac7ef46fc7ace">ODP_SCHED_NO_WAIT</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga9116776b8262a74af7dac7ef46fc7ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do not wait. <br /></td></tr>
<tr class="separator:ga9116776b8262a74af7dac7ef46fc7ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90bf46fce3105dfa3bb2e5f258a7236a"><td class="memItemLeft" align="right" valign="top"><a id="ga90bf46fce3105dfa3bb2e5f258a7236a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga90bf46fce3105dfa3bb2e5f258a7236a">ODP_SCHED_GROUP_NAME_LEN</a>&#160;&#160;&#160;32</td></tr>
<tr class="memdesc:ga90bf46fce3105dfa3bb2e5f258a7236a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum schedule group name length, including the null character. <br /></td></tr>
<tr class="separator:ga90bf46fce3105dfa3bb2e5f258a7236a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ba135fc660e1c050aa25ec6744ec584"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga2ba135fc660e1c050aa25ec6744ec584">ODP_SCHED_SYNC_PARALLEL</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga2ba135fc660e1c050aa25ec6744ec584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel scheduled queues.  <a href="group__odp__scheduler.html#ga2ba135fc660e1c050aa25ec6744ec584">More...</a><br /></td></tr>
<tr class="separator:ga2ba135fc660e1c050aa25ec6744ec584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b7efc5cfc27ef416312f5adb8bdc392"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga4b7efc5cfc27ef416312f5adb8bdc392">ODP_SCHED_SYNC_ATOMIC</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga4b7efc5cfc27ef416312f5adb8bdc392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic queue synchronization.  <a href="group__odp__scheduler.html#ga4b7efc5cfc27ef416312f5adb8bdc392">More...</a><br /></td></tr>
<tr class="separator:ga4b7efc5cfc27ef416312f5adb8bdc392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4df3696ebf4528ecc6e69ae3fff040fd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga4df3696ebf4528ecc6e69ae3fff040fd">ODP_SCHED_SYNC_ORDERED</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:ga4df3696ebf4528ecc6e69ae3fff040fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordered queue synchronization.  <a href="group__odp__scheduler.html#ga4df3696ebf4528ecc6e69ae3fff040fd">More...</a><br /></td></tr>
<tr class="separator:ga4df3696ebf4528ecc6e69ae3fff040fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a6ab4ff9386d9a4ffcb4b19d516a3fb"><td class="memItemLeft" align="right" valign="top"><a id="ga8a6ab4ff9386d9a4ffcb4b19d516a3fb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga8a6ab4ff9386d9a4ffcb4b19d516a3fb">ODP_SCHED_GROUP_INVALID</a>&#160;&#160;&#160;((<a class="el" href="group__odp__scheduler.html#ga3cd27b316530d297eab83d851bf2deb8">odp_schedule_group_t</a>)-1)</td></tr>
<tr class="memdesc:ga8a6ab4ff9386d9a4ffcb4b19d516a3fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid scheduler group. <br /></td></tr>
<tr class="separator:ga8a6ab4ff9386d9a4ffcb4b19d516a3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf463b15ad978dac0bf77c0110232b504"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#gaf463b15ad978dac0bf77c0110232b504">ODP_SCHED_GROUP_ALL</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:gaf463b15ad978dac0bf77c0110232b504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Group of all threads.  <a href="group__odp__scheduler.html#gaf463b15ad978dac0bf77c0110232b504">More...</a><br /></td></tr>
<tr class="separator:gaf463b15ad978dac0bf77c0110232b504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72125b596aa5d2e61dd61e177516e24e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga72125b596aa5d2e61dd61e177516e24e">ODP_SCHED_GROUP_WORKER</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga72125b596aa5d2e61dd61e177516e24e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Group of all worker threads.  <a href="group__odp__scheduler.html#ga72125b596aa5d2e61dd61e177516e24e">More...</a><br /></td></tr>
<tr class="separator:ga72125b596aa5d2e61dd61e177516e24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8d0a3ad4e57fabf61aa84b59e688a13"><td class="memItemLeft" align="right" valign="top"><a id="gae8d0a3ad4e57fabf61aa84b59e688a13"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#gae8d0a3ad4e57fabf61aa84b59e688a13">ODP_SCHED_GROUP_CONTROL</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:gae8d0a3ad4e57fabf61aa84b59e688a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predefined scheduler group of all control threads. <br /></td></tr>
<tr class="separator:gae8d0a3ad4e57fabf61aa84b59e688a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4056228780619667bc0256a5c0544c9f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga4056228780619667bc0256a5c0544c9f">ODP_SCHED_MAX_PRIOS</a>&#160;&#160;&#160;16</td></tr>
<tr class="memdesc:ga4056228780619667bc0256a5c0544c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of scheduling priorities supported by the API.  <a href="group__odp__scheduler.html#ga4056228780619667bc0256a5c0544c9f">More...</a><br /></td></tr>
<tr class="separator:ga4056228780619667bc0256a5c0544c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga05c15f8076326b98fe2fc534dcc6b319"><td class="memItemLeft" align="right" valign="top"><a id="ga05c15f8076326b98fe2fc534dcc6b319"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga05c15f8076326b98fe2fc534dcc6b319">odp_schedule_sync_t</a></td></tr>
<tr class="memdesc:ga05c15f8076326b98fe2fc534dcc6b319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduler synchronization method. <br /></td></tr>
<tr class="separator:ga05c15f8076326b98fe2fc534dcc6b319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cd27b316530d297eab83d851bf2deb8"><td class="memItemLeft" align="right" valign="top"><a id="ga3cd27b316530d297eab83d851bf2deb8"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga3cd27b316530d297eab83d851bf2deb8">odp_schedule_group_t</a></td></tr>
<tr class="memdesc:ga3cd27b316530d297eab83d851bf2deb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduler thread group. <br /></td></tr>
<tr class="separator:ga3cd27b316530d297eab83d851bf2deb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33e9d26217f2f689b2611298dec5daf7"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga33e9d26217f2f689b2611298dec5daf7">odp_schedule_prio_t</a></td></tr>
<tr class="memdesc:ga33e9d26217f2f689b2611298dec5daf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling priority level.  <a href="group__odp__scheduler.html#ga33e9d26217f2f689b2611298dec5daf7">More...</a><br /></td></tr>
<tr class="separator:ga33e9d26217f2f689b2611298dec5daf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f168fef5bfd38bc561966c7fe069938"><td class="memItemLeft" align="right" valign="top"><a id="ga7f168fef5bfd38bc561966c7fe069938"></a>
typedef struct <a class="el" href="structodp__schedule__param__t.html">odp_schedule_param_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga7f168fef5bfd38bc561966c7fe069938">odp_schedule_param_t</a></td></tr>
<tr class="memdesc:ga7f168fef5bfd38bc561966c7fe069938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduler parameters. <br /></td></tr>
<tr class="separator:ga7f168fef5bfd38bc561966c7fe069938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86a101e18c1dfcf21e2ff23f376858a4"><td class="memItemLeft" align="right" valign="top"><a id="ga86a101e18c1dfcf21e2ff23f376858a4"></a>
typedef struct <a class="el" href="structodp__schedule__capability__t.html">odp_schedule_capability_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga86a101e18c1dfcf21e2ff23f376858a4">odp_schedule_capability_t</a></td></tr>
<tr class="memdesc:ga86a101e18c1dfcf21e2ff23f376858a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduler capabilities. <br /></td></tr>
<tr class="separator:ga86a101e18c1dfcf21e2ff23f376858a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42877e75362bbc9db285a339260ddd6d"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structodp__cache__stash__region__t.html">odp_cache_stash_region_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga42877e75362bbc9db285a339260ddd6d">odp_cache_stash_region_t</a></td></tr>
<tr class="memdesc:ga42877e75362bbc9db285a339260ddd6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Region specific cache stashing configuration.  <a href="group__odp__scheduler.html#ga42877e75362bbc9db285a339260ddd6d">More...</a><br /></td></tr>
<tr class="separator:ga42877e75362bbc9db285a339260ddd6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade66c2965a584f7a26c13a16f82d9cf6"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structodp__cache__stash__config__t.html">odp_cache_stash_config_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#gade66c2965a584f7a26c13a16f82d9cf6">odp_cache_stash_config_t</a></td></tr>
<tr class="memdesc:gade66c2965a584f7a26c13a16f82d9cf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache stashing configuration.  <a href="group__odp__scheduler.html#gade66c2965a584f7a26c13a16f82d9cf6">More...</a><br /></td></tr>
<tr class="separator:gade66c2965a584f7a26c13a16f82d9cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09cc9a726b9258f6a3c9e988f3f2fb9b"><td class="memItemLeft" align="right" valign="top"><a id="ga09cc9a726b9258f6a3c9e988f3f2fb9b"></a>
typedef struct <a class="el" href="structodp__cache__stash__prio__config__t.html">odp_cache_stash_prio_config_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga09cc9a726b9258f6a3c9e988f3f2fb9b">odp_cache_stash_prio_config_t</a></td></tr>
<tr class="memdesc:ga09cc9a726b9258f6a3c9e988f3f2fb9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Priority specific cache stashing configuration. <br /></td></tr>
<tr class="separator:ga09cc9a726b9258f6a3c9e988f3f2fb9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bf7f96714a867ec07c3bc4d0a5e190e"><td class="memItemLeft" align="right" valign="top"><a id="ga4bf7f96714a867ec07c3bc4d0a5e190e"></a>
typedef struct <a class="el" href="structodp__schedule__group__param__t.html">odp_schedule_group_param_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga4bf7f96714a867ec07c3bc4d0a5e190e">odp_schedule_group_param_t</a></td></tr>
<tr class="memdesc:ga4bf7f96714a867ec07c3bc4d0a5e190e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule group parameters. <br /></td></tr>
<tr class="separator:ga4bf7f96714a867ec07c3bc4d0a5e190e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga535b77a27ebe6031c1f579b97f989c8d"><td class="memItemLeft" align="right" valign="top"><a id="ga535b77a27ebe6031c1f579b97f989c8d"></a>
typedef struct <a class="el" href="structodp__schedule__config__t.html">odp_schedule_config_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga535b77a27ebe6031c1f579b97f989c8d">odp_schedule_config_t</a></td></tr>
<tr class="memdesc:ga535b77a27ebe6031c1f579b97f989c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule configuration. <br /></td></tr>
<tr class="separator:ga535b77a27ebe6031c1f579b97f989c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae19b1849213f57b9c85dec6168e6b466"><td class="memItemLeft" align="right" valign="top"><a id="gae19b1849213f57b9c85dec6168e6b466"></a>
typedef struct <a class="el" href="structodp__schedule__group__info__t.html">odp_schedule_group_info_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#gae19b1849213f57b9c85dec6168e6b466">odp_schedule_group_info_t</a></td></tr>
<tr class="memdesc:gae19b1849213f57b9c85dec6168e6b466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule group information. <br /></td></tr>
<tr class="separator:gae19b1849213f57b9c85dec6168e6b466"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab0a0d2673cc7371d5c5d782d13a485b8"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#gab0a0d2673cc7371d5c5d782d13a485b8">odp_schedule_wait_time</a> (uint64_t ns)</td></tr>
<tr class="memdesc:gab0a0d2673cc7371d5c5d782d13a485b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule wait time.  <a href="group__odp__scheduler.html#gab0a0d2673cc7371d5c5d782d13a485b8">More...</a><br /></td></tr>
<tr class="separator:gab0a0d2673cc7371d5c5d782d13a485b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4ca1012ebb16ff8b9752b958dc45ce6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__odp__event.html#ga51942509e0d072db63a565cbc1e7204d">odp_event_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#gae4ca1012ebb16ff8b9752b958dc45ce6">odp_schedule</a> (<a class="el" href="group__odp__queue.html#ga378c44e791a84a1160f870e3d995db96">odp_queue_t</a> *from, uint64_t wait)</td></tr>
<tr class="memdesc:gae4ca1012ebb16ff8b9752b958dc45ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule an event.  <a href="group__odp__scheduler.html#gae4ca1012ebb16ff8b9752b958dc45ce6">More...</a><br /></td></tr>
<tr class="separator:gae4ca1012ebb16ff8b9752b958dc45ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34f1bae924466cc2b57563f8fe2dc0d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga34f1bae924466cc2b57563f8fe2dc0d1">odp_schedule_multi</a> (<a class="el" href="group__odp__queue.html#ga378c44e791a84a1160f870e3d995db96">odp_queue_t</a> *from, uint64_t wait, <a class="el" href="group__odp__event.html#ga51942509e0d072db63a565cbc1e7204d">odp_event_t</a> events[], int num)</td></tr>
<tr class="memdesc:ga34f1bae924466cc2b57563f8fe2dc0d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule multiple events.  <a href="group__odp__scheduler.html#ga34f1bae924466cc2b57563f8fe2dc0d1">More...</a><br /></td></tr>
<tr class="separator:ga34f1bae924466cc2b57563f8fe2dc0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa388723ac8b02b37675476fabd8fb014"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#gaa388723ac8b02b37675476fabd8fb014">odp_schedule_multi_wait</a> (<a class="el" href="group__odp__queue.html#ga378c44e791a84a1160f870e3d995db96">odp_queue_t</a> *from, <a class="el" href="group__odp__event.html#ga51942509e0d072db63a565cbc1e7204d">odp_event_t</a> events[], int num)</td></tr>
<tr class="memdesc:gaa388723ac8b02b37675476fabd8fb014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule, wait for events.  <a href="group__odp__scheduler.html#gaa388723ac8b02b37675476fabd8fb014">More...</a><br /></td></tr>
<tr class="separator:gaa388723ac8b02b37675476fabd8fb014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17ae1ac2ac704684d0a7087a311c73f4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga17ae1ac2ac704684d0a7087a311c73f4">odp_schedule_multi_no_wait</a> (<a class="el" href="group__odp__queue.html#ga378c44e791a84a1160f870e3d995db96">odp_queue_t</a> *from, <a class="el" href="group__odp__event.html#ga51942509e0d072db63a565cbc1e7204d">odp_event_t</a> events[], int num)</td></tr>
<tr class="memdesc:ga17ae1ac2ac704684d0a7087a311c73f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule, do not wait for events.  <a href="group__odp__scheduler.html#ga17ae1ac2ac704684d0a7087a311c73f4">More...</a><br /></td></tr>
<tr class="separator:ga17ae1ac2ac704684d0a7087a311c73f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9868ccb25b6631ef29cc921ee2e522b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga9868ccb25b6631ef29cc921ee2e522b0">odp_schedule_pause</a> (void)</td></tr>
<tr class="memdesc:ga9868ccb25b6631ef29cc921ee2e522b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause scheduling.  <a href="group__odp__scheduler.html#ga9868ccb25b6631ef29cc921ee2e522b0">More...</a><br /></td></tr>
<tr class="separator:ga9868ccb25b6631ef29cc921ee2e522b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf16f217bd1654f854a720130dbd01a49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#gaf16f217bd1654f854a720130dbd01a49">odp_schedule_resume</a> (void)</td></tr>
<tr class="memdesc:gaf16f217bd1654f854a720130dbd01a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume scheduling.  <a href="group__odp__scheduler.html#gaf16f217bd1654f854a720130dbd01a49">More...</a><br /></td></tr>
<tr class="separator:gaf16f217bd1654f854a720130dbd01a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bfbbe5a45d721f9af622296fa97b8e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga7bfbbe5a45d721f9af622296fa97b8e4">odp_schedule_release_atomic</a> (void)</td></tr>
<tr class="memdesc:ga7bfbbe5a45d721f9af622296fa97b8e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the current atomic context.  <a href="group__odp__scheduler.html#ga7bfbbe5a45d721f9af622296fa97b8e4">More...</a><br /></td></tr>
<tr class="separator:ga7bfbbe5a45d721f9af622296fa97b8e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab9e0e2bfa0f014069ae7b66bdba0065"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#gaab9e0e2bfa0f014069ae7b66bdba0065">odp_schedule_release_ordered</a> (void)</td></tr>
<tr class="memdesc:gaab9e0e2bfa0f014069ae7b66bdba0065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the current ordered context.  <a href="group__odp__scheduler.html#gaab9e0e2bfa0f014069ae7b66bdba0065">More...</a><br /></td></tr>
<tr class="separator:gaab9e0e2bfa0f014069ae7b66bdba0065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa17b9ca6d2b8bd76e31023779455474c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#gaa17b9ca6d2b8bd76e31023779455474c">odp_schedule_prefetch</a> (int num)</td></tr>
<tr class="memdesc:gaa17b9ca6d2b8bd76e31023779455474c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefetch events for next schedule call.  <a href="group__odp__scheduler.html#gaa17b9ca6d2b8bd76e31023779455474c">More...</a><br /></td></tr>
<tr class="separator:gaa17b9ca6d2b8bd76e31023779455474c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d91b9144cf2ccdcb112b7376a38aeaf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga9d91b9144cf2ccdcb112b7376a38aeaf">odp_schedule_max_prio</a> (void)</td></tr>
<tr class="memdesc:ga9d91b9144cf2ccdcb112b7376a38aeaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum scheduling priority level.  <a href="group__odp__scheduler.html#ga9d91b9144cf2ccdcb112b7376a38aeaf">More...</a><br /></td></tr>
<tr class="separator:ga9d91b9144cf2ccdcb112b7376a38aeaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53b421f0656421e67cc7fd841e5576b5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga53b421f0656421e67cc7fd841e5576b5">odp_schedule_min_prio</a> (void)</td></tr>
<tr class="memdesc:ga53b421f0656421e67cc7fd841e5576b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum scheduling priority level.  <a href="group__odp__scheduler.html#ga53b421f0656421e67cc7fd841e5576b5">More...</a><br /></td></tr>
<tr class="separator:ga53b421f0656421e67cc7fd841e5576b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94034a7f591f3f549099aebb098f7e05"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga94034a7f591f3f549099aebb098f7e05">odp_schedule_default_prio</a> (void)</td></tr>
<tr class="memdesc:ga94034a7f591f3f549099aebb098f7e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default scheduling priority level.  <a href="group__odp__scheduler.html#ga94034a7f591f3f549099aebb098f7e05">More...</a><br /></td></tr>
<tr class="separator:ga94034a7f591f3f549099aebb098f7e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae380898e8c1cac6a96cd539a7603a31d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#gae380898e8c1cac6a96cd539a7603a31d">odp_schedule_num_prio</a> (void)</td></tr>
<tr class="memdesc:gae380898e8c1cac6a96cd539a7603a31d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of scheduling priorities.  <a href="group__odp__scheduler.html#gae380898e8c1cac6a96cd539a7603a31d">More...</a><br /></td></tr>
<tr class="separator:gae380898e8c1cac6a96cd539a7603a31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f3af33a2a42b3a9d6e5e3f74bfcb03d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga3f3af33a2a42b3a9d6e5e3f74bfcb03d">odp_schedule_config_init</a> (<a class="el" href="structodp__schedule__config__t.html">odp_schedule_config_t</a> *config)</td></tr>
<tr class="memdesc:ga3f3af33a2a42b3a9d6e5e3f74bfcb03d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize schedule configuration options.  <a href="group__odp__scheduler.html#ga3f3af33a2a42b3a9d6e5e3f74bfcb03d">More...</a><br /></td></tr>
<tr class="separator:ga3f3af33a2a42b3a9d6e5e3f74bfcb03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1b51ebd46adeb6aa7805fccb00144df"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#gaa1b51ebd46adeb6aa7805fccb00144df">odp_schedule_config</a> (const <a class="el" href="structodp__schedule__config__t.html">odp_schedule_config_t</a> *config)</td></tr>
<tr class="memdesc:gaa1b51ebd46adeb6aa7805fccb00144df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global schedule configuration.  <a href="group__odp__scheduler.html#gaa1b51ebd46adeb6aa7805fccb00144df">More...</a><br /></td></tr>
<tr class="separator:gaa1b51ebd46adeb6aa7805fccb00144df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabde3ebecd35c0442a2e2a20144af0d80"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#gabde3ebecd35c0442a2e2a20144af0d80">odp_schedule_capability</a> (<a class="el" href="structodp__schedule__capability__t.html">odp_schedule_capability_t</a> *capa)</td></tr>
<tr class="memdesc:gabde3ebecd35c0442a2e2a20144af0d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query scheduler capabilities.  <a href="group__odp__scheduler.html#gabde3ebecd35c0442a2e2a20144af0d80">More...</a><br /></td></tr>
<tr class="separator:gabde3ebecd35c0442a2e2a20144af0d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade17d812771d4e386aac0810b05fa0e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__odp__scheduler.html#ga3cd27b316530d297eab83d851bf2deb8">odp_schedule_group_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#gade17d812771d4e386aac0810b05fa0e5">odp_schedule_group_create</a> (const char *name, const <a class="el" href="group__odp__thread.html#ga3081b44d12fa54bb3d39e16299d6c321">odp_thrmask_t</a> *mask)</td></tr>
<tr class="memdesc:gade17d812771d4e386aac0810b05fa0e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule group create.  <a href="group__odp__scheduler.html#gade17d812771d4e386aac0810b05fa0e5">More...</a><br /></td></tr>
<tr class="separator:gade17d812771d4e386aac0810b05fa0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41ac90524a7b661bb26bb854a79bd9a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga41ac90524a7b661bb26bb854a79bd9a1">odp_schedule_group_param_init</a> (<a class="el" href="structodp__schedule__group__param__t.html">odp_schedule_group_param_t</a> *param)</td></tr>
<tr class="memdesc:ga41ac90524a7b661bb26bb854a79bd9a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize schedule group parameters.  <a href="group__odp__scheduler.html#ga41ac90524a7b661bb26bb854a79bd9a1">More...</a><br /></td></tr>
<tr class="separator:ga41ac90524a7b661bb26bb854a79bd9a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadab95746abecbd83fb7eba3a7af36f5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__odp__scheduler.html#ga3cd27b316530d297eab83d851bf2deb8">odp_schedule_group_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#gadab95746abecbd83fb7eba3a7af36f5d">odp_schedule_group_create_2</a> (const char *name, const <a class="el" href="group__odp__thread.html#ga3081b44d12fa54bb3d39e16299d6c321">odp_thrmask_t</a> *mask, const <a class="el" href="structodp__schedule__group__param__t.html">odp_schedule_group_param_t</a> *param)</td></tr>
<tr class="memdesc:gadab95746abecbd83fb7eba3a7af36f5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule group create with parameters.  <a href="group__odp__scheduler.html#gadab95746abecbd83fb7eba3a7af36f5d">More...</a><br /></td></tr>
<tr class="separator:gadab95746abecbd83fb7eba3a7af36f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga789089301ab1da404d927deace0c2492"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga789089301ab1da404d927deace0c2492">odp_schedule_group_destroy</a> (<a class="el" href="group__odp__scheduler.html#ga3cd27b316530d297eab83d851bf2deb8">odp_schedule_group_t</a> group)</td></tr>
<tr class="memdesc:ga789089301ab1da404d927deace0c2492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule group destroy.  <a href="group__odp__scheduler.html#ga789089301ab1da404d927deace0c2492">More...</a><br /></td></tr>
<tr class="separator:ga789089301ab1da404d927deace0c2492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5021b647374ccf445765138c520aea2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__odp__scheduler.html#ga3cd27b316530d297eab83d851bf2deb8">odp_schedule_group_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga5021b647374ccf445765138c520aea2c">odp_schedule_group_lookup</a> (const char *name)</td></tr>
<tr class="memdesc:ga5021b647374ccf445765138c520aea2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up a schedule group by name.  <a href="group__odp__scheduler.html#ga5021b647374ccf445765138c520aea2c">More...</a><br /></td></tr>
<tr class="separator:ga5021b647374ccf445765138c520aea2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f7a7ab39ee69f8538edd9dd506127b6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga3f7a7ab39ee69f8538edd9dd506127b6">odp_schedule_group_join</a> (<a class="el" href="group__odp__scheduler.html#ga3cd27b316530d297eab83d851bf2deb8">odp_schedule_group_t</a> group, const <a class="el" href="group__odp__thread.html#ga3081b44d12fa54bb3d39e16299d6c321">odp_thrmask_t</a> *mask)</td></tr>
<tr class="memdesc:ga3f7a7ab39ee69f8538edd9dd506127b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a schedule group.  <a href="group__odp__scheduler.html#ga3f7a7ab39ee69f8538edd9dd506127b6">More...</a><br /></td></tr>
<tr class="separator:ga3f7a7ab39ee69f8538edd9dd506127b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f8b1785115b6d2be6aae0f5614dc604"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga7f8b1785115b6d2be6aae0f5614dc604">odp_schedule_group_leave</a> (<a class="el" href="group__odp__scheduler.html#ga3cd27b316530d297eab83d851bf2deb8">odp_schedule_group_t</a> group, const <a class="el" href="group__odp__thread.html#ga3081b44d12fa54bb3d39e16299d6c321">odp_thrmask_t</a> *mask)</td></tr>
<tr class="memdesc:ga7f8b1785115b6d2be6aae0f5614dc604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Leave a schedule group.  <a href="group__odp__scheduler.html#ga7f8b1785115b6d2be6aae0f5614dc604">More...</a><br /></td></tr>
<tr class="separator:ga7f8b1785115b6d2be6aae0f5614dc604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f82ee3eb52b2a0af6c1629334942b5c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga0f82ee3eb52b2a0af6c1629334942b5c">odp_schedule_group_thrmask</a> (<a class="el" href="group__odp__scheduler.html#ga3cd27b316530d297eab83d851bf2deb8">odp_schedule_group_t</a> group, <a class="el" href="group__odp__thread.html#ga3081b44d12fa54bb3d39e16299d6c321">odp_thrmask_t</a> *thrmask)</td></tr>
<tr class="memdesc:ga0f82ee3eb52b2a0af6c1629334942b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a schedule group's thrmask.  <a href="group__odp__scheduler.html#ga0f82ee3eb52b2a0af6c1629334942b5c">More...</a><br /></td></tr>
<tr class="separator:ga0f82ee3eb52b2a0af6c1629334942b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad76f3ebf512c382a95cb64ac2b843c7f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#gad76f3ebf512c382a95cb64ac2b843c7f">odp_schedule_group_info</a> (<a class="el" href="group__odp__scheduler.html#ga3cd27b316530d297eab83d851bf2deb8">odp_schedule_group_t</a> group, <a class="el" href="structodp__schedule__group__info__t.html">odp_schedule_group_info_t</a> *info)</td></tr>
<tr class="memdesc:gad76f3ebf512c382a95cb64ac2b843c7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve information about a schedule group.  <a href="group__odp__scheduler.html#gad76f3ebf512c382a95cb64ac2b843c7f">More...</a><br /></td></tr>
<tr class="separator:gad76f3ebf512c382a95cb64ac2b843c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2edc549b1aa00dca77abe94575145e9"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#gaa2edc549b1aa00dca77abe94575145e9">odp_schedule_group_to_u64</a> (<a class="el" href="group__odp__scheduler.html#ga3cd27b316530d297eab83d851bf2deb8">odp_schedule_group_t</a> group)</td></tr>
<tr class="memdesc:gaa2edc549b1aa00dca77abe94575145e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get printable value for schedule group handle.  <a href="group__odp__scheduler.html#gaa2edc549b1aa00dca77abe94575145e9">More...</a><br /></td></tr>
<tr class="separator:gaa2edc549b1aa00dca77abe94575145e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb827ae9d816cc6e3bade16f2e4ce00d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#gafb827ae9d816cc6e3bade16f2e4ce00d">odp_schedule_order_lock</a> (uint32_t lock_index)</td></tr>
<tr class="memdesc:gafb827ae9d816cc6e3bade16f2e4ce00d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire ordered context lock.  <a href="group__odp__scheduler.html#gafb827ae9d816cc6e3bade16f2e4ce00d">More...</a><br /></td></tr>
<tr class="separator:gafb827ae9d816cc6e3bade16f2e4ce00d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f07fe4b73a14a6ef06414a2c10ddc2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga8f07fe4b73a14a6ef06414a2c10ddc2a">odp_schedule_order_unlock</a> (uint32_t lock_index)</td></tr>
<tr class="memdesc:ga8f07fe4b73a14a6ef06414a2c10ddc2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release ordered context lock.  <a href="group__odp__scheduler.html#ga8f07fe4b73a14a6ef06414a2c10ddc2a">More...</a><br /></td></tr>
<tr class="separator:ga8f07fe4b73a14a6ef06414a2c10ddc2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4a9ff2ad12781e8ee8cfd722ec7cd5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#gaf4a9ff2ad12781e8ee8cfd722ec7cd5c">odp_schedule_order_unlock_lock</a> (uint32_t unlock_index, uint32_t lock_index)</td></tr>
<tr class="memdesc:gaf4a9ff2ad12781e8ee8cfd722ec7cd5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release existing ordered context lock and acquire a new lock.  <a href="group__odp__scheduler.html#gaf4a9ff2ad12781e8ee8cfd722ec7cd5c">More...</a><br /></td></tr>
<tr class="separator:gaf4a9ff2ad12781e8ee8cfd722ec7cd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a2c49c450d10a8d1493f49bb8bda497"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga4a2c49c450d10a8d1493f49bb8bda497">odp_schedule_order_lock_start</a> (uint32_t lock_index)</td></tr>
<tr class="memdesc:ga4a2c49c450d10a8d1493f49bb8bda497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous ordered context lock Request an ordered context lock to be acquired.  <a href="group__odp__scheduler.html#ga4a2c49c450d10a8d1493f49bb8bda497">More...</a><br /></td></tr>
<tr class="separator:ga4a2c49c450d10a8d1493f49bb8bda497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39473bcdcdf480a827cbbf6249aee394"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga39473bcdcdf480a827cbbf6249aee394">odp_schedule_order_lock_wait</a> (uint32_t lock_index)</td></tr>
<tr class="memdesc:ga39473bcdcdf480a827cbbf6249aee394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous ordered context lock wait Wait for a previously started lock acquire operation to finish.  <a href="group__odp__scheduler.html#ga39473bcdcdf480a827cbbf6249aee394">More...</a><br /></td></tr>
<tr class="separator:ga39473bcdcdf480a827cbbf6249aee394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2106dfb7642c88dda358759575558baf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga2106dfb7642c88dda358759575558baf">odp_schedule_order_wait</a> (void)</td></tr>
<tr class="memdesc:ga2106dfb7642c88dda358759575558baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until the currently held scheduling context is the first in order.  <a href="group__odp__scheduler.html#ga2106dfb7642c88dda358759575558baf">More...</a><br /></td></tr>
<tr class="separator:ga2106dfb7642c88dda358759575558baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae92168433885df11eed3d22040b68e38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#gae92168433885df11eed3d22040b68e38">odp_schedule_print</a> (void)</td></tr>
<tr class="memdesc:gae92168433885df11eed3d22040b68e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print debug info about scheduler.  <a href="group__odp__scheduler.html#gae92168433885df11eed3d22040b68e38">More...</a><br /></td></tr>
<tr class="separator:gae92168433885df11eed3d22040b68e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga2ba135fc660e1c050aa25ec6744ec584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ba135fc660e1c050aa25ec6744ec584">&#9670;&nbsp;</a></span>ODP_SCHED_SYNC_PARALLEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ODP_SCHED_SYNC_PARALLEL&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parallel scheduled queues. </p>
<p>The scheduler performs priority scheduling, load balancing, prefetching, etc functions but does not provide additional event synchronization or ordering. It's free to schedule events from single parallel queue to multiple threads for concurrent processing. Application is responsible for queue context synchronization and event ordering (SW synchronization). </p>

</div>
</div>
<a id="ga4b7efc5cfc27ef416312f5adb8bdc392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b7efc5cfc27ef416312f5adb8bdc392">&#9670;&nbsp;</a></span>ODP_SCHED_SYNC_ATOMIC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ODP_SCHED_SYNC_ATOMIC&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic queue synchronization. </p>
<p>Events from an atomic queue can be scheduled only to a single thread at a time. The thread is guaranteed to have exclusive (atomic) access to the associated queue context, which enables the user to avoid SW synchronization. Atomic queue also helps to maintain event ordering since only one thread at a time is able to process events from a queue.</p>
<p>The atomic queue synchronization context is dedicated to the thread until it requests another event from the scheduler, which implicitly releases the context. User may allow the scheduler to release the context earlier than that by calling <a class="el" href="group__odp__scheduler.html#ga7bfbbe5a45d721f9af622296fa97b8e4" title="Release the current atomic context.">odp_schedule_release_atomic()</a>. However, this call is just a hint to the implementation and the context may be held until the next schedule call.</p>
<p>When scheduler is enabled as flow-aware, the event flow id value affects scheduling of the event and synchronization is maintained per flow within each queue. </p>

</div>
</div>
<a id="ga4df3696ebf4528ecc6e69ae3fff040fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4df3696ebf4528ecc6e69ae3fff040fd">&#9670;&nbsp;</a></span>ODP_SCHED_SYNC_ORDERED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ODP_SCHED_SYNC_ORDERED&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ordered queue synchronization. </p>
<p>Events from an ordered queue can be scheduled to multiple threads for concurrent processing but still maintain the original event order. This enables the user to achieve high single flow throughput by avoiding SW synchronization for ordering between threads.</p>
<p>When <a class="el" href="group__odp__scheduler.html#gae4ca1012ebb16ff8b9752b958dc45ce6" title="Schedule an event.">odp_schedule()</a> returns an event, the calling thread is associated with an ordered scheduling synchronization context. The contexts arising from the same ordered queue have the same mutual ordering as the corresponding events had in the queue.</p>
<p>When <a class="el" href="group__odp__scheduler.html#ga34f1bae924466cc2b57563f8fe2dc0d1" title="Schedule multiple events.">odp_schedule_multi()</a> returns more than one event from an ordered queue, the events returned were consecutive in the queue and the calling thread is associated with single ordered scheduling synchronization context that is ordered with respect to other contexts as if just the first event was returned.</p>
<p>When threads holding ordered scheduling synchronization contexts, which arise from the same ordered queue, enqueue events to destination queues, the order of events in each destination queue will be as follows:</p>
<ul>
<li>Events enqueued by one thread have the order in which the enqueue calls were made.</li>
<li>Two events enqueued by different threads have the same mutual order as the scheduling synchronization contexts of the enqueuing threads.</li>
</ul>
<p>The ordering rules above apply to all events, not just those that were scheduled from the ordered queue. For instance, newly allocated events and previously stored events are ordered in the destination queue based on the scheduling synchronization context. The ordering rules apply regarless of the type (scheduled or plain) or schedule type (atomic, ordered, or parallel) of the destination queue. If the order type of the destination queue is ODP_QUEUE_ORDER_IGNORE, then the order between events enqueued by different threads is not guaranteed.</p>
<p>An ordered scheduling synchronization context is implicitly released when the thread holding the context requests a new event from the scheduler. User may allow the scheduler to release the context earlier than that by calling <a class="el" href="group__odp__scheduler.html#gaab9e0e2bfa0f014069ae7b66bdba0065" title="Release the current ordered context.">odp_schedule_release_ordered()</a>. However, this call is just a hint to the implementation and the context may be held until the next schedule call.</p>
<p>Enqueue calls by different threads may return in a different order than the final order of the enqueued events in the destination queue.</p>
<p>Unnecessary event re-ordering may be avoided for those destination queues that do not need to maintain the specified event order by setting 'order' queue parameter to ODP_QUEUE_ORDER_IGNORE.</p>
<p>When scheduler is enabled as flow-aware, the event flow id value affects scheduling of the event and synchronization is maintained and order is defined per flow within each queue. </p>

</div>
</div>
<a id="gaf463b15ad978dac0bf77c0110232b504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf463b15ad978dac0bf77c0110232b504">&#9670;&nbsp;</a></span>ODP_SCHED_GROUP_ALL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ODP_SCHED_GROUP_ALL&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Group of all threads. </p>
<p>All active worker and control threads belong to this group. The group is automatically updated when new threads enter or old threads exit ODP. </p>

</div>
</div>
<a id="ga72125b596aa5d2e61dd61e177516e24e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72125b596aa5d2e61dd61e177516e24e">&#9670;&nbsp;</a></span>ODP_SCHED_GROUP_WORKER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ODP_SCHED_GROUP_WORKER&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Group of all worker threads. </p>
<p>All active worker threads belong to this group. The group is automatically updated when new worker threads enter or old threads exit ODP. </p>

</div>
</div>
<a id="ga4056228780619667bc0256a5c0544c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4056228780619667bc0256a5c0544c9f">&#9670;&nbsp;</a></span>ODP_SCHED_MAX_PRIOS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ODP_SCHED_MAX_PRIOS&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of scheduling priorities supported by the API. </p>
<p>See <a class="el" href="structodp__schedule__capability__t.html#ac1777a9f5e710b4482129d066a4ded8e" title="Number of scheduling priorities.">odp_schedule_capability_t::max_prios</a> for implementation specific maximum priority count. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga33e9d26217f2f689b2611298dec5daf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33e9d26217f2f689b2611298dec5daf7">&#9670;&nbsp;</a></span>odp_schedule_prio_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="group__odp__scheduler.html#ga33e9d26217f2f689b2611298dec5daf7">odp_schedule_prio_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling priority level. </p>
<p>Priority level is a non-negative integer value between <a class="el" href="group__odp__scheduler.html#ga53b421f0656421e67cc7fd841e5576b5" title="Minimum scheduling priority level.">odp_schedule_min_prio()</a> and <a class="el" href="group__odp__scheduler.html#ga9d91b9144cf2ccdcb112b7376a38aeaf" title="Maximum scheduling priority level.">odp_schedule_max_prio()</a>. Queues with a higher priority value are served with higher priority than queues with a lower priority value. </p>

<p class="definition">Definition at line <a class="el" href="spec_2schedule__types_8h_source.html#l00184">184</a> of file <a class="el" href="spec_2schedule__types_8h_source.html">spec/schedule_types.h</a>.</p>

</div>
</div>
<a id="ga42877e75362bbc9db285a339260ddd6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42877e75362bbc9db285a339260ddd6d">&#9670;&nbsp;</a></span>odp_cache_stash_region_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structodp__cache__stash__region__t.html">odp_cache_stash_region_t</a> <a class="el" href="structodp__cache__stash__region__t.html">odp_cache_stash_region_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Region specific cache stashing configuration. </p>
<p>Region specific cache stashing configuration for different cache levels. Application can, for example, configure caching of certain portions of a region to L2 while configuring another portion to be cached to L3 or alternatively caching to both levels by configuring overlapping offsets and byte counts. </p>

</div>
</div>
<a id="gade66c2965a584f7a26c13a16f82d9cf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade66c2965a584f7a26c13a16f82d9cf6">&#9670;&nbsp;</a></span>odp_cache_stash_config_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structodp__cache__stash__config__t.html">odp_cache_stash_config_t</a> <a class="el" href="structodp__cache__stash__config__t.html">odp_cache_stash_config_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cache stashing configuration. </p>
<p>Cache stashing configuration for different data regions. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab0a0d2673cc7371d5c5d782d13a485b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0a0d2673cc7371d5c5d782d13a485b8">&#9670;&nbsp;</a></span>odp_schedule_wait_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t odp_schedule_wait_time </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule wait time. </p>
<p>Converts nanoseconds to wait values for other schedule functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Nanoseconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value for the wait parameter in schedule functions </dd></dl>

</div>
</div>
<a id="gae4ca1012ebb16ff8b9752b958dc45ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4ca1012ebb16ff8b9752b958dc45ce6">&#9670;&nbsp;</a></span>odp_schedule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__odp__event.html#ga51942509e0d072db63a565cbc1e7204d">odp_event_t</a> odp_schedule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__odp__queue.html#ga378c44e791a84a1160f870e3d995db96">odp_queue_t</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>wait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule an event. </p>
<p>Run event scheduler to find the next highest priority event which is available for the calling thread. Only queues that have been created with ODP_QUEUE_TYPE_SCHED type are connected to the scheduler. Optionally, outputs the source queue of the event. If there's no event available, waits for an event according to the wait parameter setting. Returns ODP_EVENT_INVALID if reaches end of the wait period.</p>
<p>When returns an event, the thread holds the queue synchronization context (atomic or ordered) until the next schedule call (e.g. <a class="el" href="group__odp__scheduler.html#gae4ca1012ebb16ff8b9752b958dc45ce6" title="Schedule an event.">odp_schedule()</a> or <a class="el" href="group__odp__scheduler.html#ga34f1bae924466cc2b57563f8fe2dc0d1" title="Schedule multiple events.">odp_schedule_multi()</a>). The next call implicitly releases the current context and potentially returns with a new context. User can allow early context release (e.g., see <a class="el" href="group__odp__scheduler.html#ga7bfbbe5a45d721f9af622296fa97b8e4" title="Release the current atomic context.">odp_schedule_release_atomic()</a> and <a class="el" href="group__odp__scheduler.html#gaab9e0e2bfa0f014069ae7b66bdba0065" title="Release the current ordered context.">odp_schedule_release_ordered()</a>) for performance optimization.</p>
<p>When successful, this function acts as an acquire memory barrier between the sender and the receiver (the calling thread) of the event. The receiver sees correctly the memory stores done by the sender before it enqueued the event.</p>
<p>When the event was scheduled from an atomic queue, this function acts as an acquire memory barrier between the previous holder of the same atomic synchronization context and the calling thread. When the context is released, a release memory barrier is performed towards the next holder of the context. This ensures that memory stores done when holding an atomic context are correctly visible to other threads that will subsequently hold the same atomic context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>Output parameter for the source queue (where the event was dequeued from). Ignored if NULL. </td></tr>
    <tr><td class="paramname">wait</td><td>Minimum time to wait for an event. Waits indefinitely if set to ODP_SCHED_WAIT. Does not wait if set to ODP_SCHED_NO_WAIT. Use <a class="el" href="group__odp__scheduler.html#gab0a0d2673cc7371d5c5d782d13a485b8" title="Schedule wait time.">odp_schedule_wait_time()</a> to convert time to other wait values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next highest priority event </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ODP_EVENT_INVALID</td><td>on timeout and no events available</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__odp__scheduler.html#ga34f1bae924466cc2b57563f8fe2dc0d1" title="Schedule multiple events.">odp_schedule_multi()</a>, <a class="el" href="group__odp__scheduler.html#ga7bfbbe5a45d721f9af622296fa97b8e4" title="Release the current atomic context.">odp_schedule_release_atomic()</a>, <a class="el" href="group__odp__scheduler.html#gaab9e0e2bfa0f014069ae7b66bdba0065" title="Release the current ordered context.">odp_schedule_release_ordered()</a> </dd></dl>

</div>
</div>
<a id="ga34f1bae924466cc2b57563f8fe2dc0d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34f1bae924466cc2b57563f8fe2dc0d1">&#9670;&nbsp;</a></span>odp_schedule_multi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int odp_schedule_multi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__odp__queue.html#ga378c44e791a84a1160f870e3d995db96">odp_queue_t</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>wait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__odp__event.html#ga51942509e0d072db63a565cbc1e7204d">odp_event_t</a>&#160;</td>
          <td class="paramname"><em>events</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule multiple events. </p>
<p>Like <a class="el" href="group__odp__scheduler.html#gae4ca1012ebb16ff8b9752b958dc45ce6" title="Schedule an event.">odp_schedule()</a>, but returns multiple events from a queue. The caller specifies the maximum number of events it is willing to accept. The scheduler is under no obligation to return more than a single event but will never return more than the number specified by the caller. The return code specifies the number of events returned and all of these events always originate from the same source queue and share the same scheduler synchronization context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>Output parameter for the source queue (where the event was dequeued from). Ignored if NULL. </td></tr>
    <tr><td class="paramname">wait</td><td>Minimum time to wait for an event. Waits infinitely, if set to ODP_SCHED_WAIT. Does not wait, if set to ODP_SCHED_NO_WAIT. Use <a class="el" href="group__odp__scheduler.html#gab0a0d2673cc7371d5c5d782d13a485b8" title="Schedule wait time.">odp_schedule_wait_time()</a> to convert time to other wait values. </td></tr>
    <tr><td class="paramname">events</td><td>Event array for output </td></tr>
    <tr><td class="paramname">num</td><td>Maximum number of events to output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of events outputted (0 ... num) </dd></dl>

</div>
</div>
<a id="gaa388723ac8b02b37675476fabd8fb014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa388723ac8b02b37675476fabd8fb014">&#9670;&nbsp;</a></span>odp_schedule_multi_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int odp_schedule_multi_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__odp__queue.html#ga378c44e791a84a1160f870e3d995db96">odp_queue_t</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__odp__event.html#ga51942509e0d072db63a565cbc1e7204d">odp_event_t</a>&#160;</td>
          <td class="paramname"><em>events</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule, wait for events. </p>
<p>Like <a class="el" href="group__odp__scheduler.html#ga34f1bae924466cc2b57563f8fe2dc0d1" title="Schedule multiple events.">odp_schedule_multi()</a>, but waits infinitely for events.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">from</td><td>Output parameter for the source queue (where the event was dequeued from). Ignored if NULL. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">events</td><td>Event array for output </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">num</td><td>Maximum number of events to output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of events outputted (1 ... num) </dd></dl>

</div>
</div>
<a id="ga17ae1ac2ac704684d0a7087a311c73f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17ae1ac2ac704684d0a7087a311c73f4">&#9670;&nbsp;</a></span>odp_schedule_multi_no_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int odp_schedule_multi_no_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__odp__queue.html#ga378c44e791a84a1160f870e3d995db96">odp_queue_t</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__odp__event.html#ga51942509e0d072db63a565cbc1e7204d">odp_event_t</a>&#160;</td>
          <td class="paramname"><em>events</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule, do not wait for events. </p>
<p>Like <a class="el" href="group__odp__scheduler.html#ga34f1bae924466cc2b57563f8fe2dc0d1" title="Schedule multiple events.">odp_schedule_multi()</a>, but does not wait for events.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">from</td><td>Output parameter for the source queue (where the event was dequeued from). Ignored if NULL. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">events</td><td>Event array for output </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">num</td><td>Maximum number of events to output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of events outputted (0 ... num) </dd></dl>

</div>
</div>
<a id="ga9868ccb25b6631ef29cc921ee2e522b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9868ccb25b6631ef29cc921ee2e522b0">&#9670;&nbsp;</a></span>odp_schedule_pause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void odp_schedule_pause </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pause scheduling. </p>
<p>Pause global scheduling for this thread. After this call, only ODP_SCHED_NO_WAIT schedule calls are allowed and these calls will return only locally pre-scheduled events (if any). User can exit the schedule loop only after the schedule function indicates that there's no more (pre-scheduled) events.</p>
<p>Example call pattern:</p>
<p>while (!stop) { odp_event_t ev = odp_schedule(NULL, ODP_SCHED_WAIT); // Process event }</p>
<p><a class="el" href="group__odp__scheduler.html#ga9868ccb25b6631ef29cc921ee2e522b0" title="Pause scheduling.">odp_schedule_pause()</a>;</p>
<p>while (1) { odp_event_t ev = odp_schedule(NULL, ODP_SCHED_NO_WAIT); if (ev == ODP_EVENT_INVALID) break; odp_event_free(ev); } </p>

</div>
</div>
<a id="gaf16f217bd1654f854a720130dbd01a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf16f217bd1654f854a720130dbd01a49">&#9670;&nbsp;</a></span>odp_schedule_resume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void odp_schedule_resume </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resume scheduling. </p>
<p>Resume global scheduling for this thread. After this call, all schedule calls will schedule normally (perform global scheduling). </p>

</div>
</div>
<a id="ga7bfbbe5a45d721f9af622296fa97b8e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bfbbe5a45d721f9af622296fa97b8e4">&#9670;&nbsp;</a></span>odp_schedule_release_atomic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void odp_schedule_release_atomic </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release the current atomic context. </p>
<p>This call is valid only for source queues with atomic synchronization. It hints the scheduler that the user has completed critical section processing in the current atomic context. The scheduler is now allowed to schedule events from the same queue to another thread. However, the context may be still held until the next <a class="el" href="group__odp__scheduler.html#gae4ca1012ebb16ff8b9752b958dc45ce6" title="Schedule an event.">odp_schedule()</a> or <a class="el" href="group__odp__scheduler.html#ga34f1bae924466cc2b57563f8fe2dc0d1" title="Schedule multiple events.">odp_schedule_multi()</a> call - this call allows but does not force the scheduler to release the context early.</p>
<p>Early atomic context release may increase parallelism and thus system performance, but user needs to design carefully the split into critical vs. non-critical sections. </p>

</div>
</div>
<a id="gaab9e0e2bfa0f014069ae7b66bdba0065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab9e0e2bfa0f014069ae7b66bdba0065">&#9670;&nbsp;</a></span>odp_schedule_release_ordered()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void odp_schedule_release_ordered </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release the current ordered context. </p>
<p>This call is valid only for source queues with ordered synchronization. It hints the scheduler that the user has done all enqueues that need to maintain event order in the current ordered context. The scheduler is allowed to release the ordered context of this thread and avoid reordering any following enqueues. However, the context may be still held until the next <a class="el" href="group__odp__scheduler.html#gae4ca1012ebb16ff8b9752b958dc45ce6" title="Schedule an event.">odp_schedule()</a> or <a class="el" href="group__odp__scheduler.html#ga34f1bae924466cc2b57563f8fe2dc0d1" title="Schedule multiple events.">odp_schedule_multi()</a> call - this call allows but does not force the scheduler to release the context early.</p>
<p>Early ordered context release may increase parallelism and thus system performance, since scheduler may start reordering events sooner than the next schedule call. </p>

</div>
</div>
<a id="gaa17b9ca6d2b8bd76e31023779455474c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa17b9ca6d2b8bd76e31023779455474c">&#9670;&nbsp;</a></span>odp_schedule_prefetch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void odp_schedule_prefetch </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prefetch events for next schedule call. </p>
<p>Hint the scheduler that application is about to finish processing the current event(s) and will soon request more events. The scheduling context status is not affect. The call does not guarantee that the next schedule call will return any number of events. It may improve system performance, since the scheduler may prefetch the next (batch of) event(s) in parallel to application processing the current event(s).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>Number of events to prefetch </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9d91b9144cf2ccdcb112b7376a38aeaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d91b9144cf2ccdcb112b7376a38aeaf">&#9670;&nbsp;</a></span>odp_schedule_max_prio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int odp_schedule_max_prio </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum scheduling priority level. </p>
<p>This is the global maximum value that can be set to 'prio' field in <a class="el" href="structodp__schedule__param__t.html" title="Scheduler parameters.">odp_schedule_param_t</a> (e.g. <a class="el" href="group__odp__queue.html#gab985be8c3947fef3da257e16948bf0f0" title="Queue create.">odp_queue_create()</a>). Configured based on <a class="el" href="structodp__schedule__config__t.html#aedbbc187deda51a3b081d1af2c5ab2b2" title="Priority range configuration.">odp_schedule_config_t::prio</a>. Queues with a higher priority value are served with higher priority than queues with a lower priority value.</p>
<p>Schedule group specific maximum priority (see <a class="el" href="structodp__schedule__group__param__t.html#a95b7f9d8ae973a0c46f642b72d8afe85" title="Group specific priority configuration.">odp_schedule_group_param_t::prio</a>) can be queried with <a class="el" href="group__odp__scheduler.html#gad76f3ebf512c382a95cb64ac2b843c7f" title="Retrieve information about a schedule group.">odp_schedule_group_info()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Maximum scheduling priority level </dd></dl>

</div>
</div>
<a id="ga53b421f0656421e67cc7fd841e5576b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53b421f0656421e67cc7fd841e5576b5">&#9670;&nbsp;</a></span>odp_schedule_min_prio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int odp_schedule_min_prio </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum scheduling priority level. </p>
<p>This is the global minimum value that can be set to 'prio' field in <a class="el" href="structodp__schedule__param__t.html" title="Scheduler parameters.">odp_schedule_param_t</a> (e.g. <a class="el" href="group__odp__queue.html#gab985be8c3947fef3da257e16948bf0f0" title="Queue create.">odp_queue_create()</a>). Configured based on <a class="el" href="structodp__schedule__config__t.html#aedbbc187deda51a3b081d1af2c5ab2b2" title="Priority range configuration.">odp_schedule_config_t::prio</a>. Queues with a higher priority value are served with higher priority than queues with a lower priority value.</p>
<p>Schedule group specific minimum priority (see <a class="el" href="structodp__schedule__group__param__t.html#a95b7f9d8ae973a0c46f642b72d8afe85" title="Group specific priority configuration.">odp_schedule_group_param_t::prio</a>) can be queried with <a class="el" href="group__odp__scheduler.html#gad76f3ebf512c382a95cb64ac2b843c7f" title="Retrieve information about a schedule group.">odp_schedule_group_info()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Minimum scheduling priority level </dd></dl>

</div>
</div>
<a id="ga94034a7f591f3f549099aebb098f7e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94034a7f591f3f549099aebb098f7e05">&#9670;&nbsp;</a></span>odp_schedule_default_prio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int odp_schedule_default_prio </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default scheduling priority level. </p>
<p>This is the global default value of 'prio' field in <a class="el" href="structodp__schedule__param__t.html" title="Scheduler parameters.">odp_schedule_param_t</a> (e.g. <a class="el" href="group__odp__queue.html#ga6fc2ea5eb86152210342f7377d1468e4" title="Initialize queue params.">odp_queue_param_init()</a>). Configured based on <a class="el" href="structodp__schedule__config__t.html#aedbbc187deda51a3b081d1af2c5ab2b2" title="Priority range configuration.">odp_schedule_config_t::prio</a>. The default value should be suitable for an application that uses single priority level for all its queues (uses scheduler only for load balancing and synchronization). Typically, the default value is between minimum and maximum values, but with a few priority levels it may be close or equal to those.</p>
<dl class="section return"><dt>Returns</dt><dd>Default scheduling priority level </dd></dl>

</div>
</div>
<a id="gae380898e8c1cac6a96cd539a7603a31d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae380898e8c1cac6a96cd539a7603a31d">&#9670;&nbsp;</a></span>odp_schedule_num_prio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int odp_schedule_num_prio </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of scheduling priorities. </p>
<p>The number of global priority levels support by the scheduler. It equals to <a class="el" href="group__odp__scheduler.html#ga9d91b9144cf2ccdcb112b7376a38aeaf" title="Maximum scheduling priority level.">odp_schedule_max_prio()</a> - <a class="el" href="group__odp__scheduler.html#ga53b421f0656421e67cc7fd841e5576b5" title="Minimum scheduling priority level.">odp_schedule_min_prio()</a> + 1. Configured based on <a class="el" href="structodp__schedule__config__t.html#aedbbc187deda51a3b081d1af2c5ab2b2" title="Priority range configuration.">odp_schedule_config_t::prio</a>.</p>
<p>Schedule group specific priority count (see <a class="el" href="structodp__schedule__group__param__t.html#a95b7f9d8ae973a0c46f642b72d8afe85" title="Group specific priority configuration.">odp_schedule_group_param_t::prio</a>) can be queried with <a class="el" href="group__odp__scheduler.html#gad76f3ebf512c382a95cb64ac2b843c7f" title="Retrieve information about a schedule group.">odp_schedule_group_info()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Number of scheduling priorities </dd></dl>

</div>
</div>
<a id="ga3f3af33a2a42b3a9d6e5e3f74bfcb03d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f3af33a2a42b3a9d6e5e3f74bfcb03d">&#9670;&nbsp;</a></span>odp_schedule_config_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void odp_schedule_config_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structodp__schedule__config__t.html">odp_schedule_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize schedule configuration options. </p>
<p>Initialize an <a class="el" href="structodp__schedule__config__t.html" title="Schedule configuration.">odp_schedule_config_t</a> to its default values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">config</td><td>Pointer to schedule configuration structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa1b51ebd46adeb6aa7805fccb00144df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1b51ebd46adeb6aa7805fccb00144df">&#9670;&nbsp;</a></span>odp_schedule_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int odp_schedule_config </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structodp__schedule__config__t.html">odp_schedule_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Global schedule configuration. </p>
<p>Initialize and configure scheduler with global configuration options to schedule events across different scheduled queues. This function must be called only once and before scheduler is used (any other scheduler function is called except <a class="el" href="group__odp__scheduler.html#gabde3ebecd35c0442a2e2a20144af0d80" title="Query scheduler capabilities.">odp_schedule_capability()</a> and <a class="el" href="group__odp__scheduler.html#ga3f3af33a2a42b3a9d6e5e3f74bfcb03d" title="Initialize schedule configuration options.">odp_schedule_config_init()</a>) or any queues are created (by application itself or by other ODP modules). An application can pass NULL value to use default configuration. It will have the same result as filling the structure with <a class="el" href="group__odp__scheduler.html#ga3f3af33a2a42b3a9d6e5e3f74bfcb03d" title="Initialize schedule configuration options.">odp_schedule_config_init()</a> and then passing it to <a class="el" href="group__odp__scheduler.html#gaa1b51ebd46adeb6aa7805fccb00144df" title="Global schedule configuration.">odp_schedule_config()</a>.</p>
<p>The initialization sequence should be:</p><ul>
<li><a class="el" href="group__odp__scheduler.html#gabde3ebecd35c0442a2e2a20144af0d80" title="Query scheduler capabilities.">odp_schedule_capability()</a></li>
<li><a class="el" href="group__odp__scheduler.html#ga3f3af33a2a42b3a9d6e5e3f74bfcb03d" title="Initialize schedule configuration options.">odp_schedule_config_init()</a></li>
<li><a class="el" href="group__odp__scheduler.html#gaa1b51ebd46adeb6aa7805fccb00144df" title="Global schedule configuration.">odp_schedule_config()</a></li>
<li><a class="el" href="group__odp__scheduler.html#gae4ca1012ebb16ff8b9752b958dc45ce6" title="Schedule an event.">odp_schedule()</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>Pointer to scheduler configuration structure or NULL for the default configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">&lt;0</td><td>on failure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__odp__scheduler.html#gabde3ebecd35c0442a2e2a20144af0d80" title="Query scheduler capabilities.">odp_schedule_capability()</a>, <a class="el" href="group__odp__scheduler.html#ga3f3af33a2a42b3a9d6e5e3f74bfcb03d" title="Initialize schedule configuration options.">odp_schedule_config_init()</a> </dd></dl>

</div>
</div>
<a id="gabde3ebecd35c0442a2e2a20144af0d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabde3ebecd35c0442a2e2a20144af0d80">&#9670;&nbsp;</a></span>odp_schedule_capability()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int odp_schedule_capability </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structodp__schedule__capability__t.html">odp_schedule_capability_t</a> *&#160;</td>
          <td class="paramname"><em>capa</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query scheduler capabilities. </p>
<p>Outputs schedule capabilities on success.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">capa</td><td>Pointer to capability structure for output</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">&lt;0</td><td>on failure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gade17d812771d4e386aac0810b05fa0e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade17d812771d4e386aac0810b05fa0e5">&#9670;&nbsp;</a></span>odp_schedule_group_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__odp__scheduler.html#ga3cd27b316530d297eab83d851bf2deb8">odp_schedule_group_t</a> odp_schedule_group_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__odp__thread.html#ga3081b44d12fa54bb3d39e16299d6c321">odp_thrmask_t</a> *&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule group create. </p>
<p>Creates a schedule group with the thread mask. Only threads in the mask will receive events from a queue that belongs to the schedule group. Thread masks of various schedule groups may overlap. There are predefined groups, such as ODP_SCHED_GROUP_ALL and ODP_SCHED_GROUP_WORKER, which are present by default and are automatically updated. The use of group name is optional. Unique names are not required. However, <a class="el" href="group__odp__scheduler.html#ga5021b647374ccf445765138c520aea2c" title="Look up a schedule group by name.">odp_schedule_group_lookup()</a> returns only a single matching group.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the schedule group or NULL. Maximum string length is ODP_SCHED_GROUP_NAME_LEN, including the null character. </td></tr>
    <tr><td class="paramname">mask</td><td>Thread mask</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Schedule group handle </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ODP_SCHED_GROUP_INVALID</td><td>on failure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__odp__scheduler.html#gaf463b15ad978dac0bf77c0110232b504" title="Group of all threads.">ODP_SCHED_GROUP_ALL</a>, <a class="el" href="group__odp__scheduler.html#ga72125b596aa5d2e61dd61e177516e24e" title="Group of all worker threads.">ODP_SCHED_GROUP_WORKER</a> </dd></dl>

</div>
</div>
<a id="ga41ac90524a7b661bb26bb854a79bd9a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41ac90524a7b661bb26bb854a79bd9a1">&#9670;&nbsp;</a></span>odp_schedule_group_param_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void odp_schedule_group_param_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structodp__schedule__group__param__t.html">odp_schedule_group_param_t</a> *&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize schedule group parameters. </p>
<p>Initialize an <a class="el" href="structodp__schedule__group__param__t.html" title="Schedule group parameters.">odp_schedule_group_param_t</a> to its default values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">param</td><td>Pointer to parameter structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadab95746abecbd83fb7eba3a7af36f5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadab95746abecbd83fb7eba3a7af36f5d">&#9670;&nbsp;</a></span>odp_schedule_group_create_2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__odp__scheduler.html#ga3cd27b316530d297eab83d851bf2deb8">odp_schedule_group_t</a> odp_schedule_group_create_2 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__odp__thread.html#ga3081b44d12fa54bb3d39e16299d6c321">odp_thrmask_t</a> *&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structodp__schedule__group__param__t.html">odp_schedule_group_param_t</a> *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule group create with parameters. </p>
<p>Otherwise like <a class="el" href="group__odp__scheduler.html#gade17d812771d4e386aac0810b05fa0e5" title="Schedule group create.">odp_schedule_group_create()</a> but additionally accepts a set of parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the schedule group or NULL. Maximum string length is ODP_SCHED_GROUP_NAME_LEN, including the null character. </td></tr>
    <tr><td class="paramname">mask</td><td>Thread mask </td></tr>
    <tr><td class="paramname">param</td><td>Schedule group parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Schedule group handle </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ODP_SCHED_GROUP_INVALID</td><td>on failure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__odp__scheduler.html#gade17d812771d4e386aac0810b05fa0e5" title="Schedule group create.">odp_schedule_group_create()</a> </dd></dl>

</div>
</div>
<a id="ga789089301ab1da404d927deace0c2492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga789089301ab1da404d927deace0c2492">&#9670;&nbsp;</a></span>odp_schedule_group_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int odp_schedule_group_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__odp__scheduler.html#ga3cd27b316530d297eab83d851bf2deb8">odp_schedule_group_t</a>&#160;</td>
          <td class="paramname"><em>group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule group destroy. </p>
<p>Destroys a schedule group. All queues belonging to the schedule group must be destroyed before destroying the group. Other operations on this group must not be invoked in parallel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>Schedule group handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">&lt;0</td><td>on failure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5021b647374ccf445765138c520aea2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5021b647374ccf445765138c520aea2c">&#9670;&nbsp;</a></span>odp_schedule_group_lookup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__odp__scheduler.html#ga3cd27b316530d297eab83d851bf2deb8">odp_schedule_group_t</a> odp_schedule_group_lookup </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up a schedule group by name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of schedule group</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle of the first matching schedule group </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ODP_SCHED_GROUP_INVALID</td><td>No matching schedule group found </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3f7a7ab39ee69f8538edd9dd506127b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f7a7ab39ee69f8538edd9dd506127b6">&#9670;&nbsp;</a></span>odp_schedule_group_join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int odp_schedule_group_join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__odp__scheduler.html#ga3cd27b316530d297eab83d851bf2deb8">odp_schedule_group_t</a>&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__odp__thread.html#ga3081b44d12fa54bb3d39e16299d6c321">odp_thrmask_t</a> *&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join a schedule group. </p>
<p>Join a threadmask to an existing schedule group</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>Schedule group handle </td></tr>
    <tr><td class="paramname">mask</td><td>Thread mask</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">&lt;0</td><td>on failure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7f8b1785115b6d2be6aae0f5614dc604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f8b1785115b6d2be6aae0f5614dc604">&#9670;&nbsp;</a></span>odp_schedule_group_leave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int odp_schedule_group_leave </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__odp__scheduler.html#ga3cd27b316530d297eab83d851bf2deb8">odp_schedule_group_t</a>&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__odp__thread.html#ga3081b44d12fa54bb3d39e16299d6c321">odp_thrmask_t</a> *&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Leave a schedule group. </p>
<p>Remove a threadmask from an existing schedule group</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>Schedule group handle </td></tr>
    <tr><td class="paramname">mask</td><td>Thread mask</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">&lt;0</td><td>on failure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Leaving a schedule group means threads in the specified mask will no longer receive events from queues belonging to the specified schedule group. This effect is not instantaneous, however, and events that have been prestaged may still be presented to the masked threads. </dd></dl>

</div>
</div>
<a id="ga0f82ee3eb52b2a0af6c1629334942b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f82ee3eb52b2a0af6c1629334942b5c">&#9670;&nbsp;</a></span>odp_schedule_group_thrmask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int odp_schedule_group_thrmask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__odp__scheduler.html#ga3cd27b316530d297eab83d851bf2deb8">odp_schedule_group_t</a>&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__odp__thread.html#ga3081b44d12fa54bb3d39e16299d6c321">odp_thrmask_t</a> *&#160;</td>
          <td class="paramname"><em>thrmask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a schedule group's thrmask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">group</td><td>Schedule group handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">thrmask</td><td>The current thrmask used for this schedule group</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success </td></tr>
    <tr><td class="paramname">&lt;0</td><td>Invalid group specified </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad76f3ebf512c382a95cb64ac2b843c7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad76f3ebf512c382a95cb64ac2b843c7f">&#9670;&nbsp;</a></span>odp_schedule_group_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int odp_schedule_group_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__odp__scheduler.html#ga3cd27b316530d297eab83d851bf2deb8">odp_schedule_group_t</a>&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structodp__schedule__group__info__t.html">odp_schedule_group_info_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve information about a schedule group. </p>
<p>Fills in schedule group information structure with current values. The call is not synchronized with calls modifying the schedule group. So, the application should ensure that it does not simultaneously modify and retrieve information about the same group with this call. The call is not intended for fast path use. The info structure is written only on success.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">group</td><td>Schedule group handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>Pointer to schedule group info struct for output</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success </td></tr>
    <tr><td class="paramname">&lt;0</td><td>On failure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa2edc549b1aa00dca77abe94575145e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2edc549b1aa00dca77abe94575145e9">&#9670;&nbsp;</a></span>odp_schedule_group_to_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t odp_schedule_group_to_u64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__odp__scheduler.html#ga3cd27b316530d297eab83d851bf2deb8">odp_schedule_group_t</a>&#160;</td>
          <td class="paramname"><em>group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get printable value for schedule group handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>Handle to be converted for debugging</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint64_t value that can be used to print/display this handle </dd></dl>

</div>
</div>
<a id="gafb827ae9d816cc6e3bade16f2e4ce00d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb827ae9d816cc6e3bade16f2e4ce00d">&#9670;&nbsp;</a></span>odp_schedule_order_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void odp_schedule_order_lock </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lock_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquire ordered context lock. </p>
<p>This call is valid only when holding an ordered synchronization context. Ordered locks are used to protect critical sections that are executed within an ordered context. Threads enter the critical section in the order determined by the context (source queue). Lock ordering is automatically skipped for threads that release the context instead of using the lock.</p>
<p>The number of ordered locks available is set by the lock_count parameter of the schedule parameters passed to <a class="el" href="group__odp__queue.html#gab985be8c3947fef3da257e16948bf0f0" title="Queue create.">odp_queue_create()</a>, which must be less than or equal to queue capability 'max_ordered_locks'. If this routine is called outside of an ordered context or with a lock_index that exceeds the number of available ordered locks in this context results are undefined. The number of ordered locks associated with a given ordered queue may be queried by the <a class="el" href="group__odp__queue.html#ga420874d79ccbc465c8b6be4127bfe824" title="Queue lock count.">odp_queue_lock_count()</a> API.</p>
<p>Each ordered lock may be used only once per ordered context. If events are to be processed with multiple ordered critical sections, each should be protected by its own ordered lock. This promotes maximum parallelism by allowing order to maintained on a more granular basis. If an ordered lock is used multiple times in the same ordered context results are undefined. Only one ordered lock can be active in an ordered context at any given time. Results are undefined when multiple ordered locks are acquired in nested fashion within the same ordered context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock_index</td><td>Index of the ordered lock in the current context to be acquired. Must be in the range 0..<a class="el" href="group__odp__queue.html#ga420874d79ccbc465c8b6be4127bfe824" title="Queue lock count.">odp_queue_lock_count()</a><ul>
<li>1 </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8f07fe4b73a14a6ef06414a2c10ddc2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f07fe4b73a14a6ef06414a2c10ddc2a">&#9670;&nbsp;</a></span>odp_schedule_order_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void odp_schedule_order_unlock </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lock_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release ordered context lock. </p>
<p>This call is valid only when holding an ordered synchronization context. Release a previously locked ordered context lock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock_index</td><td>Index of the ordered lock in the current context to be released. Results are undefined if the caller does not hold this lock. Must be in the range 0..<a class="el" href="group__odp__queue.html#ga420874d79ccbc465c8b6be4127bfe824" title="Queue lock count.">odp_queue_lock_count()</a> - 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf4a9ff2ad12781e8ee8cfd722ec7cd5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4a9ff2ad12781e8ee8cfd722ec7cd5c">&#9670;&nbsp;</a></span>odp_schedule_order_unlock_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void odp_schedule_order_unlock_lock </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>unlock_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lock_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release existing ordered context lock and acquire a new lock. </p>
<p>This call is valid only when holding an ordered synchronization context. Release a previously locked ordered context lock and acquire a new ordered context lock. The operation is equivalent to application calling first odp_schedule_order_unlock(unlock_index) and then odp_schedule_order_lock(lock_index). The same constraints apply with this call as with those two.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unlock_index</td><td>Index of the acquired ordered lock in the current context to be released. </td></tr>
    <tr><td class="paramname">lock_index</td><td>Index of the ordered lock in the current context to be acquired. Must be in the range 0...<a class="el" href="group__odp__queue.html#ga420874d79ccbc465c8b6be4127bfe824" title="Queue lock count.">odp_queue_lock_count()</a> - 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__odp__scheduler.html#gafb827ae9d816cc6e3bade16f2e4ce00d" title="Acquire ordered context lock.">odp_schedule_order_lock()</a>, <a class="el" href="group__odp__scheduler.html#ga8f07fe4b73a14a6ef06414a2c10ddc2a" title="Release ordered context lock.">odp_schedule_order_unlock()</a> </dd></dl>

</div>
</div>
<a id="ga4a2c49c450d10a8d1493f49bb8bda497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a2c49c450d10a8d1493f49bb8bda497">&#9670;&nbsp;</a></span>odp_schedule_order_lock_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void odp_schedule_order_lock_start </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lock_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous ordered context lock Request an ordered context lock to be acquired. </p>
<p>Starts an ordered context lock acquire operation, but does not wait until the lock has been acquired. Application can use this call to potentially interleave some processing within waiting for this lock. Each start lock call must be paired with a wait call that blocks until the lock has been acquired. Locks cannot be acquired in nested fashion i.e each start call must follow a paring wait and unlock calls, before using another lock. The same constraints apply as with <a class="el" href="group__odp__scheduler.html#gafb827ae9d816cc6e3bade16f2e4ce00d" title="Acquire ordered context lock.">odp_schedule_order_lock()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock_index</td><td>Index of the ordered lock in the current context to start acquire operation. Must be in the range 0..<a class="el" href="group__odp__queue.html#ga420874d79ccbc465c8b6be4127bfe824" title="Queue lock count.">odp_queue_lock_count()</a> - 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga39473bcdcdf480a827cbbf6249aee394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39473bcdcdf480a827cbbf6249aee394">&#9670;&nbsp;</a></span>odp_schedule_order_lock_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void odp_schedule_order_lock_wait </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lock_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous ordered context lock wait Wait for a previously started lock acquire operation to finish. </p>
<p>Lock index must match with the previous start call. Ordered lock acquisition will be completed during this call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock_index</td><td>Index of the ordered lock in the current context to complete acquire operation. Must be in the range 0..<a class="el" href="group__odp__queue.html#ga420874d79ccbc465c8b6be4127bfe824" title="Queue lock count.">odp_queue_lock_count()</a> - 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2106dfb7642c88dda358759575558baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2106dfb7642c88dda358759575558baf">&#9670;&nbsp;</a></span>odp_schedule_order_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void odp_schedule_order_wait </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until the currently held scheduling context is the first in order. </p>
<p>Wait until there are no other scheduling contexts that precede the scheduling context of the calling thread in the source queue order. The context remains the first in order until the thread releases it.</p>
<p>This function must not be called if the current thread is not holding an ordered scheduling context or if an ordered lock is being held.</p>
<p>This functions does nothing if ordered wait is not supported.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__odp__scheduler.html#gabde3ebecd35c0442a2e2a20144af0d80" title="Query scheduler capabilities.">odp_schedule_capability()</a> </dd></dl>

</div>
</div>
<a id="gae92168433885df11eed3d22040b68e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae92168433885df11eed3d22040b68e38">&#9670;&nbsp;</a></span>odp_schedule_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void odp_schedule_print </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print debug info about scheduler. </p>
<p>Print implementation defined information about scheduler to the ODP log. The information is intended to be used for debugging. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
